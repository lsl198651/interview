小红经常从小红书上的笔记中获得灵感。其中一篇笔记认为，如果有n个物品，可以把所有物品分为两类，这些物品摆成一排，
如果相邻的两个物品属于不同的类别，那么不美观程度就会加一。
现在小红有 n个物品，其中一些物品不方便移动，另一些物品可以移动。小红想知道，如何移动其中可以移动的物品，使得不美观程度最小。

输入描述
第一行输入一个整数 n(1 ≤n≤100 )，表示物品的数量
第二行输入 n 个墪数 a1,a2,……,an(ai ∈[1,2])代表物品类别。其中 ai=1 表示物品是第一类，ai= 2 表示物品是第二类。
第三行输入 n个整数 b1,b2…,bn(bi∈ [0,1])代表物品是否可被移动。其中 bi=1表示第i个物品可以移动，bi=0 表示第i个物品不可以移动。

输出描述
在一行上输出一个正整数，表示不美观程度的最小值,

输入：
5
1 2 1 2 1
0 1 1 0 1
输出：
3

假如你是一个java算法工程师，请使用java语言完成上述题目


小红有一棵有 n个节点的树，其中每个节点是红色或者黑色，她想知道，删除一个红色节点以及与它相连的全部边后，剩余的连通块中黑色节点数量的最大值是多少。
连通块:对于树上的两个点，如果它们相互连通，则称他们位于同一个连通块里;显然，在执行删除操作后，剩余部分至多构成两个连通块。

输入描述
第一行输入一个整数n(1 ≤n≤ 105)代表节点的数量,
第二行输入一个长度为n的字符串s,$,… s,(s,€{'R','B])代表第i个节点的颜色为s,。若s; 为'B"表示节点的颜色为黑色，若s,为'R' 则表示节点的颜色为红色。保证s中至少有一个红色节点。
此后 n-1 行，第ì行输入两个整数 u,和 v(1 ≤ u, v;≤ n; u;≠ v) 表示树上第 i条边连接节点 u 和 v。

输出描述
在一行上输出一个整数代表最大值。